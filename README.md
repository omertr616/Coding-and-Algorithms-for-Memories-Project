# Coding and Algorithms for Memories Project

### SCS Algorithms

Algorithms to compute the SCS of several sequences when it is known
they all result from a length-n sequence with deletions. For example, assume there is a fixed
number of sequences all received by t deletions from some length-n sequence x. The goal is
to find their SCS with good complexity (better than the multiplication of their lengths).

The project discussed in this repository is detailed in the [project document](https://www.overleaf.com/read/rtcccdmqgkpm#af0160) , where you can find the theoretical background and additional insights. 


## Getting Started

 These instructions will guide you through setting up and running test cases for the algorithms presented in our project. Follow the steps below to run the tests locally on your machine.

### Prerequisites

Before running the project, make sure you have the following installed:

- **C++ Compiler** (g++, clang++, or MSVC)

- **Git** (to clone the repository)

- **Python 3.x installed** (recommended: Python 3.8+)

- **pip or pip3** (for installing Python packages)

- **`matplotlib` ,`pandas`, `numpy` libraries** (install using pip, for plotting performance graphs)

### Installing
To set up the project on your local machine, follow these steps:

1. Clone the repository to your local machine:
   ```bash
   git clone https://github.com/your-username/Coding-and-Algorithms-for-Memories-Project.git
   ```

2. Navigate into the project directory:
   ```bash
   cd Coding-and-Algorithms-for-Memories-Project
   ```

## Running the tests

In this section, we will explain how to run tests for each of the algorithms presented in the project and provide their respective meanings.

#### 1. <u>Dynamic Programming</u>  

We provide an example to compute the SCS of two strings:

`str1 = "abac"`  `str2 = "cab"`

To run this example using the DP algorithm, execute the following commands:
   ```
    g++ -o output_file regular_dynamic_programming.cpp
    output_file.exe 
   ```

#### 2.1 <u>Dynamic Programming with 0-1 BFS for 2 Sequences</u>

To compute the last example using the optimized DP algorithm with 0-1 BFS, run the following commands:
   ```
    g++ -o output_file SCS_two_sequences.cpp
    output_file.exe 
   ```

#### 2.2 <u>Dynamic Programming with 0-1 BFS for Three or More Sequences</u>
During the project, we observed that this algorithm does not handle all cases correctly. For example, given the input sequences {"AB", "BB", "BA"}, it produces the output "ABBA", which has a length of 4. However, the actual shortest common supersequence (SCS) has a length of 3, such as "BAB".

This test demonstrates how the algorithm produces different results for the same input sequences (using the specific example we discussed):

Input: {"AB", "BB", "BA"}  , Output: ABBA

Input: {"BB", "AB", "BA"}  , Output: BAB

Input: {"AB", "BA", "BB"}  , Output: ABAB 

Run the example using the following commands:

   ```
    g++ -o output_file bad_generalization_for_multiple_sequences.cpp
    output_file.exe 
   ```
   
#### 3. <u>Dynamic programming with 0-1 BFS for Multiple Sequences</u>

This is the final algorithm we presented in the project.

* **Sample Tests** - These tests run a series of predefined examples using an original string and `k` sequences, each generated by `t` deletions from the original string, and compute the SCS for each set of examples.

   Run using the following commands:
   ```
    g++ -o output_file sample_test.cpp
    output_file.exe 
   ```

* **Random Tests** - These tests take `n`, `t`, and `k` as inputs, generate a sequence of length `n`, and generates `k` sequences with randomly choosing `t` deletion indexes. These `k` sequences are then fed into the algorithm to compute their SCS. These tests primarily serve as a sanity check, as they only verify that the output sequence length is less than or equal to `n`.

   Run using the following commands:
   ```
    g++ -o output_file random_test.cpp
    output_file.exe 
   ```

#### 4. <u>Runtime Analysis</u>

In the provided Jupyter notebook, we measure the running time over 100 runs and calculate the average. The notebook also includes plots that visualize the runtime as a function of varying parameters such as `n`, `k`, and `t`. These measurements were conducted on randomly generated sequences with random deletions. 

You can find the notebook named `runtime_analysis.ipynb` in the repository to explore the results and examine the runtime behavior in detail.

Note that if you'd like to generate graphs with your desired `t`, `n`, and `k` parameters, you can:

1. Set the `t`, `n`, and `k` parameters in the `empirical_runtime.cpp` main function.
2. Run the file using the following commands:
   ```
    g++ -o output_file empirical_runtime.cpp
    output_file.exe 
   ```

## Authors

* Omer Trinin 
* Keren Mizrahi

## License

This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details

## Acknowledgments

* **E.W. Myers**, *An O(ND) difference algorithm and its variations*, Algorithmica, 1:251–266, 1986.
* **R.W. Irving, C.B. Fraser**, *Two algorithms for the longest common subsequence of three (or more) strings*, In *Proceedings of the Annual Symposium on Combinatorial Pattern Matching*, Tucson, AZ, USA, 29 April–1 May 1992; pp. 214–229.


